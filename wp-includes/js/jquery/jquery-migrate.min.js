/*! jQuery Migrate v1.4.1 | (c) jQuery Foundation and other contributors | jquery.org/license */

// check if jQuery.migrateMute is undefined, and set it to true
if ("undefined" == typeof jQuery.migrateMute && (jQuery.migrateMute = !0),
    function(a, b, c) {
        function d(c) {
            var d = b.console;
            // if the warning has not been issued before, log it and add it to the warnings array
            f[c] || (f[c] = !0, a.migrateWarnings.push(c), d && d.warn && !a.migrateMute && (d.warn("JQMIGRATE: " + c), a.migrateTrace && d.trace && d.trace()))
        }

        function e(b, c, e, f) {
            if (Object.defineProperty)
                try {
                    // try to define a getter and setter for the given property
                    return void Object.defineProperty(b, c, {
                        configurable: !0,
                        enumerable: !0,
                        get: function() {
                            return d(f), e
                        },
                        set: function(a) {
                            return d(f), e = a
                        }
                    })
                } catch (g) {}
            // if defining the property fails, issue a warning and assign the value directly
            a._definePropertyBroken = !0, b[c] = e
        }
    }

        // initialize variables and functions
        a.migrateVersion = "1.4.1";
        var f = {};
        a.migrateWarnings = [];

        // log a message to the console indicating that jQuery Migrate is installed
        b.console && b.console.log && b.console.log("JQMIGRATE: Migrate is installed" + (a.migrateMute ? "" : " with logging active") + ", version " + a.migrateVersion);

        // if migrateTrace is not defined, set it to true
        a.migrateTrace === c && (a.migrateTrace = !0);

        // function to reset warnings and error messages
        a.migrateReset = function() {
            f = {}, a.migrateWarnings.length = 0
        };

        // issue a warning if the document is in Quirks Mode
        "BackCompat" === document.compatMode && d("jQuery is not compatible with Quirks Mode");

        // initialize variables for attribute handling
        var g = a("<input/>", {
                size: 1
            }).attr("size") && a.attrFn,
            h = a.attr,
            i = a.attrHooks.value && a.attrHooks.value.get || function() {
                return null
            },
            j = a.attrHooks.value && a.attrHooks.value.set || function() {
                return c
            },
            k = /^(?:input|button)$/i,
            l = /^[238]$/,
            m = /^(?:autofocus|autoplay|async|checked|controls|defer|disabled|hidden|loop|multiple|open|readonly|required|scoped|selected)$/i,
            n = /^(?:checked|selected)$/i;

        // deprecate jQuery.attrFn
        e(a, "attrFn", g || {}, "jQuery.attrFn is deprecated");

        // define a new attr function to handle attributes
        jQuery.fn.attr = function (name, value) {
            var prop,
                hooks,
                elem = this[0];
        
            // don't get/set attributes on text, comment and attribute nodes
            if (!elem || elem.nodeType === 3 || elem.nodeType === 8 || elem.nodeType === 2) {
                return undefined;
            }
        
            // Fallback to prop when attributes are not supported
            if (typeof elem.getAttribute === "undefined") {
                return jQuery.prop(elem, name, value);
            }
        
            // Attribute hooks are determined by the lowercase version
            // Grab necessary hook if one is defined
            if (jQuery.isXMLDoc(elem)) {
                hooks = jQuery.propFix;
                prop = hooks[name.toLowerCase()] || name;
            } else {
                prop = name.toLowerCase();
                hooks = jQuery.propHooks[prop] || jQuery.attrHooks[prop];
            }
        }
        
            a.attr = function(elem, prop, value) {
                var hooks, ret,
                    nType = elem.nodeType;
            
                // Don't get/set attributes on text, comment and attribute nodes
                if (nType === 3 || nType === 8 || nType === 2) {
                    return;
                }
            
                // Fallback to prop when attributes are not supported
                if (typeof elem.getAttribute === "undefined") {
                    return jQuery.prop(elem, prop, value);
                }
            
                // Attribute hooks are determined by the lowercase version
                // Grab necessary hook if one is defined
                if (nType !== 1 || !jQuery.isXMLDoc(elem)) {
                    hooks = jQuery.attrHooks[prop.toLowerCase()] ||
                        (jQuery.expr.match.bool.test(prop) ? boolHook : undefined);
                }
            
                if (value !== undefined) {
                    if (value === null) {
                        jQuery.removeAttr(elem, name);
                        return;
                    }
            
                    if (hooks && "set" in hooks && (ret = hooks.set(elem, value, prop)) !== undefined) {
                        return ret;
                    }
            
                    elem.setAttribute(prop, value + "");
                    return value;
                }
            
                if (hooks && "get" in hooks && (ret = hooks.get(elem, prop)) !== null) {
                    return ret;
                }
            
                ret = elem.getAttribute(prop);
            
                // Non-existent attributes return null, we normalize to undefined
                return ret == null ? undefined : ret;
            };
            
